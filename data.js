[
  {
    "url": "https://api.github.com/repos/pliniocode/github-blog-challenge/issues/2",
    "repository_url": "https://api.github.com/repos/pliniocode/github-blog-challenge",
    "labels_url": "https://api.github.com/repos/pliniocode/github-blog-challenge/issues/2/labels{/name}",
    "comments_url": "https://api.github.com/repos/pliniocode/github-blog-challenge/issues/2/comments",
    "events_url": "https://api.github.com/repos/pliniocode/github-blog-challenge/issues/2/events",
    "html_url": "https://github.com/pliniocode/github-blog-challenge/issues/2",
    "id": 1467012385,
    "node_id": "I_kwDOIhQoTc5XcNUh",
    "number": 2,
    "title": "Notas sobre o CORS",
    "user": {
      "login": "pliniocode",
      "id": 76018725,
      "node_id": "MDQ6VXNlcjc2MDE4NzI1",
      "avatar_url": "https://avatars.githubusercontent.com/u/76018725?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pliniocode",
      "html_url": "https://github.com/pliniocode",
      "followers_url": "https://api.github.com/users/pliniocode/followers",
      "following_url": "https://api.github.com/users/pliniocode/following{/other_user}",
      "gists_url": "https://api.github.com/users/pliniocode/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pliniocode/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pliniocode/subscriptions",
      "organizations_url": "https://api.github.com/users/pliniocode/orgs",
      "repos_url": "https://api.github.com/users/pliniocode/repos",
      "events_url": "https://api.github.com/users/pliniocode/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pliniocode/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2022-11-28T20:00:17Z",
    "updated_at": "2022-11-28T20:00:17Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "O CORS (Cross-origin Resource Sharing) é um protocolo que os navegadores utilizam para acessar/compartilhar recursos de diferentes origens. \r\n\r\nEle atua por meio de cabeçalhos HTTP específicos. Por meio desses, permite-se que a origem da requisição acesse os recursos em outra origem. \r\n\r\nCaso não tenha esses cabeçalhos, a solicitação de um recurso que tenha uma origem diferente (domínio, protocolo e porta) da sua própria origem será negado. \r\n\r\nUm exemplo de requisição cross-origin: quando o front-end - example.com -  de uma aplicação faz uma requisição para uma API em - api.com -. \r\n\r\n­• Requisições CORS HTTP\r\n\r\nInicialmente é feita uma requisição CORS-preflight, que verifica se o protocolo CORS é suportado. No qual utiliza o método  “OPTIONS” que inclui cabeçalhos especiais do CORS: \r\n> Origin – a origem da fonte;\r\n> Access-Control-Request-Method – indica o método da futura requisição;\r\n> Access-Control-Request-Headers – indica os cabeçalhos da futura requisição;\r\n\r\n­• Respostas CORS HTTP\r\n\r\nAlém do status 200 ok. \r\n> Access-Control-Allow-Origin: indica se o recurso pode ser compartilhado;\r\n> Access-Control-Allow-Credentials: indica se é necessário credenciais;\r\n> Access-Control-Allow-Methods: quais métodos são aceitos;\r\n> Access-Control-Allow-Headers:  Indica quais cabeçalhos são suportados pela URL de resposta para os propósitos do protocolo;\r\n> Access-Control-Max-Age: informa o número de segundos - padrão: 5 - que as informações fornecidas pelos cabeçalhos \"Acess-Control-Allow-Methods\" e \"Acess-Control-Allow-Headers\" podem cacheadas.\r\n> Access-Control-Expose-Headers: lista quais cabeçalhos podem serem expostos na resposta.\r\n\r\n­• Requisição principal\r\n\r\nSe tudo correu bem (com a requisição CORS-preflight), o caminho está disponível para a realização da requisição principal, ora pretendida. \r\n\r\nUma nota final. A requisição CORS-preflight é invisível para o JavaScript. Quando utilizamos, por exemplo, a API Fecth, é obtido apenas a resposta da requisição principal ou um erro, caso não tenha permissão. \r\n\r\nImagem representada de uma requisição com o protocolo CORS.\r\n\r\n\r\n\r\n\r\nfontes:\r\nhttps://pt.wikipedia.org/wiki/Cross-origin_resource_sharing\r\nhttps://fetch.spec.whatwg.org/#http-cors-protocol \r\nhttps://developer.mozilla.org/pt-BR/docs/Web/HTTP/CORS \r\nhttps://www.treinaweb.com.br/blog/o-que-e-cors-e-como-resolver-os-principais-erros \r\nhttps://javascript.info/fetch-crossorigin \r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/pliniocode/github-blog-challenge/issues/2/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/pliniocode/github-blog-challenge/issues/2/timeline",
    "performed_via_github_app": null,
    "state_reason": null,
    "score": 1
  },
  {
    "url": "https://api.github.com/repos/pliniocode/github-blog-challenge/issues/1",
    "repository_url": "https://api.github.com/repos/pliniocode/github-blog-challenge",
    "labels_url": "https://api.github.com/repos/pliniocode/github-blog-challenge/issues/1/labels{/name}",
    "comments_url": "https://api.github.com/repos/pliniocode/github-blog-challenge/issues/1/comments",
    "events_url": "https://api.github.com/repos/pliniocode/github-blog-challenge/issues/1/events",
    "html_url": "https://github.com/pliniocode/github-blog-challenge/issues/1",
    "id": 1467011993,
    "node_id": "I_kwDOIhQoTc5XcNOZ",
    "number": 1,
    "title": "Quais são os segredos que os grandes programadores sabem?",
    "user": {
      "login": "pliniocode",
      "id": 76018725,
      "node_id": "MDQ6VXNlcjc2MDE4NzI1",
      "avatar_url": "https://avatars.githubusercontent.com/u/76018725?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pliniocode",
      "html_url": "https://github.com/pliniocode",
      "followers_url": "https://api.github.com/users/pliniocode/followers",
      "following_url": "https://api.github.com/users/pliniocode/following{/other_user}",
      "gists_url": "https://api.github.com/users/pliniocode/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pliniocode/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pliniocode/subscriptions",
      "organizations_url": "https://api.github.com/users/pliniocode/orgs",
      "repos_url": "https://api.github.com/users/pliniocode/repos",
      "events_url": "https://api.github.com/users/pliniocode/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pliniocode/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2022-11-28T19:59:54Z",
    "updated_at": "2022-11-28T19:59:54Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "Se te contasse, teria que te matar. Brincadeira!\r\nMais seriamente:\r\nTudo pode ser feito com hashmaps.\r\nOs gerentes sempre mentem. Esse sistema importante, que precisa estar pronto para ontem, não será analisado até dois meses após a entrega.\r\nÉ muito melhor escrever algo \"certo\" do que fazer-o rápido e com bugs. Sempre que sinta que tem que se apressar, não o faça. Faça como se tivesse todo o tempo do mundo. Sempre faça a coisa certa. Levará muito menos tempo para terminar e você se sentirá muito melhor respeito ao código.\r\nSe eles disserem: \"Não temos mais dinheiro, termine\". Então reduza o alcance, remova funcionalidades, faça menos, use metodologias topo agile, mas nunca se apresse.\r\nO efeito GIGO (do inglês:Garbage in, garbage out): Se entra lixo sairá lixo. Certifique-se de que os requisitos são os corretos.\r\nNão há funcionalidades sem documentação. Ou as documenta, ou ninguém saberá que eles existem.\r\nRTFM( Do ingles: Read the Fucking Manual, ou Lê a porcaria do manual) é má educação. A usabilidade do corredor (Hallway usability) é muito melhor. Você pode achar que isto contradiz o número 5, quizas sim ou quizas não. [[ De fato este é o principal motivo pelo qual o Windows venceu o Unix na área de trabalho. Unix e Linux estavam mais preocupados com os manuais e com a educação dos seus usuários enquanto o Windows se preocupou com a reação imediata deles. Ou seja, eles preferiram se livrar dos manuais e permitiram que as pessoas se focassem no que realmente queriam fazer. Eu nunca vi um manual para o iPhone ou para um dispositivos Android, até uma criança de 3 anos pode usá-lo. Existe uma lição para aprender aqui, mas duvido que internamente Microsoft, Apple e Google não documentem a funcionalidade e o \"como as coisas são feitas\", trabalhei para a Microsoft e tudo sempre foi documentado, o estilo sempre foi \"meia página\", o mais direto e claro possível. Os gerentes de programa eram responsáveis ​​pela análise comparativa com outros produtos e concorrentes, e os documentos eram sempre grandes, mas o estilo era o mesmo. ]]\r\nVocê aprende muito mais quando observa as pessoas usando o seu sistema. Monitore o uso e corrija-o conforme seja necessário. [Deixa-me contar uma breve história. Vinte anos atrás eu desenvolvi um sistema para alguns jovens, vamos chamá-los de secretários, que eta para armazenar e pesquisar informações sobre os pacientes. Acontece que algumas das informações foram alteradas, algumas foram excluídas e eles não estavam usando suas respectivas contas, pelo que se culpavam mutuamente. Eu troquei todas as suas senhas e gravei todas as ações numa tabela de banco de dados usada para isso. O problema aconteceu de novo e eu voltei para a minha mesa e antes de a discussão terminar apontei para uma das meninas e disse: você fez isso, neste dia, neste momento. Nunca tivemos esse problema novamente. ]\r\nO teste de unidade é muito mais eficaz que o QA tradicional. Use ambos no começo. Testes unitários são PRIMEIRO ([Unit Tests Are FIRST](https://pragprog.com/magazines/2012-01/unit-tests-are-first)) [ O objetivo de fazer testes unitários automatizados é que você nunca mais precisará usar o debugger (uma vez ao ano, tudo bem, especialmente se você precisar depurar seus testes). Escrevendo Grandes Testes Unitários: Melhores e Piores Práticas ([Writing Great Unit Tests: Best and Worst Practices](http://blog.stevensanderson.com/2009/08/24/writing-great-unit-tests-best-and-worst-practises/)), mas ao contrário da crença popular, você deve atacar de coisas internas no sistema, esta bem testar o banco de dados para atacar sistemas externos, mas não internos, então de certo modo um teste unitário é também um teste de integração interna. Mas você também deve usar seus mesmos testes de unidade como testes de integração, invertendo um switch. A regra geral para testes unitários é \"testar tudo o que pode falhar\". As 12 melhores práticas de teste de unidades selecionadas - Doces de engenharia de software ([SW Engineering Candies - Top 12 Selected Unit Testing Best Practices](http://www.sw-engineering-candies.com/blog-1/unit-testing-best-practices)) E como algumas pessoas recomendam usar uma *assert* por método de teste, isso significa que se 10 coisas falharem, você precisará escrever 10 métodos de teste, e todos terão a mesma aparência, o próximo terá apenas mais uma linha do que a anterior. Qual é o propósito disso? Você vê um teste falhar e você não precisa depurá-lo, você não precisa olhar para o código de teste, você vê o nome do teste e sabe exatamente o que falhou. Isso aumenta a produtividade 10x.]\r\nA programação funcional é a onda do futuro. Aprenda Haskell.\r\nPara estimativa, use estimativas de projetos anteriores corrigidas por dados reais. Você precisa de dados concretos para isso: use o número de telas, tabelas de banco de dados, casos de uso, etc.\r\nO controle de versão é seu amigo.\r\nO código deve ser DRY em vez de WET. [[DRY significa Don't Repeat Yourself, isso significa remover código duplicado, porque o código repetido é um pesadelo de manutenção, quando você precisa corrigir bugs, você precisa procurar por todo o código repetido, e se você trabalha com mais pessoas, eles irão copiar e colar mais rápido do que você pode resolver os bugs. WET significa Write Everything Twice e seu primo feio Write Every Time, significando exatamente o oposto de DRY: muitos e muitos códigos repetidos.]]\r\nCache de algoritmos alheios.\r\nOs riscos técnicos são controlados usando protótipos.\r\nComo todos os problemas técnicos podem ser resolvidos, todos os problemas do projeto reduzem-se a problemas organizacionais. É por isso que todas as metodologias agiles existem: para lidar com problemas organizacionais. A chave para o sucesso é \"falhar rápido\".\r\n16. Anote a retrospectiva da iteração e aja de acordo com ela.\r\nAnote e numere todos os requisitos. Use a depuração de requisitos do DSDM. Anote e numere todas as decisões de projeto usadas para resolver conceitualmente todos os requisitos. Crie protótipos para cada decisão de projeto.\r\nEntre em uma academia e vá todos os dias. Até 10 minutos de exercícios leves farão você se sentir melhor.\r\nCertifique-se de que seu código seja executado em sistemas operacionais diferentes e em bancos de dados diferentes. Use integração contínua para isso.\r\nVocê não está sendo pago para escrever código, você é pago para escrever funcionalidade. Código é apenas custo. Há custo para criá-lo, custo para depuração, custo para auditoria, custo de armazenamento, custo para manutenção etc.\r\n\r\n\r\nFonte: [Quora](https://pt.quora.com/Quais-s%C3%A3o-os-segredos-que-os-grandes-programadores-sabem)\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/pliniocode/github-blog-challenge/issues/1/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/pliniocode/github-blog-challenge/issues/1/timeline",
    "performed_via_github_app": null,
    "state_reason": null,
    "score": 1
  }
]